Исследование параллелизма.

Анализ кода и добавленные замеры времени показали, что самая времязатраная операция - propagate_flow.

Это итерационный процесс с обходом в глубину и нахождением циклов с потоками. 

Реализована идея независимого обхода от точек из разных областей, что бы процессы не конкурировали за ресурсы, под каждый процесс создаётся своя копия last_use и своя копия velocity_flow.

После выполнения независимых propagate_flow, результаты собираются в общие массивы, с преоритетом на левые области
(вся область делилась на вертикальные полосы, примерно равного размера). Рассматривались и другие варианты декомпозиции обалсти, но этот дал лучший результат.

Код запускался на задаче с полем 200x200 с использованием динамической памяти в симуляторе, на первых 10 шагах алгоритма. Для параллельного запуска и выбора кол-ва потоков добавлена опция --parallel=<кол-во потоков>.

Получились следующие результаты при 8 и 1 потоковом запуске:

Parallel = 8

Elapsed time 0: 0 ms

Elapsed time 1: 0 ms

Elapsed time 2: 0 ms

Elapsed time 3: 6 ms

Elapsed time 4: 149 ms

Elapsed time 5: 504 ms

Elapsed time 6: 370 ms

Elapsed time 7: 1183 ms

Elapsed time 8: 3017 ms

Elapsed time 9: 3901 ms

Elapsed time: 9161 ms

Elapsed time prop_flow: 9130 ms

Parallel = 1

Elapsed time 0: 0 ms

Elapsed time 1: 0 ms

Elapsed time 2: 1 ms

Elapsed time 3: 180 ms

Elapsed time 4: 1132 ms

Elapsed time 5: 1867 ms

Elapsed time 6: 2394 ms

Elapsed time 7: 6414 ms

Elapsed time 8: 4942 ms

Elapsed time 9: 6487 ms

Elapsed time: 23448 ms

Elapsed time prop_flow: 23417 ms



Очень интересно, как в итоге предполагалось это расспаралеливать!